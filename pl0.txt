Grammar:

Rule 0     S' -> program
Rule 1     program -> funclist
Rule 2     funclist -> func
Rule 3     funclist -> funclist func
Rule 4     func -> FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END
Rule 5     _1_parmlist_optional -> parmlist
Rule 6     _1_parmlist_optional -> <empty>
Rule 7     _2_locallist_optional -> locallist
Rule 8     _2_locallist_optional -> <empty>
Rule 9     parmlist -> parm
Rule 10    parmlist -> parmlist , parm
Rule 11    parm -> ID : datatype
Rule 12    datatype -> FLOAT
Rule 13    datatype -> INT
Rule 14    datatype -> FLOAT [ expr ]
Rule 15    datatype -> INT [ expr ]
Rule 16    locallist -> local ; locallist
Rule 17    locallist -> local ;
Rule 18    local -> func
Rule 19    local -> vardecl
Rule 20    vardecl -> ID : datatype
Rule 21    stmtlist -> stmt ; stmtlist
Rule 22    stmtlist -> stmt
Rule 23    stmt -> ID ( _3_exprlist_optional )
Rule 24    _3_exprlist_optional -> exprlist
Rule 25    _3_exprlist_optional -> <empty>
Rule 26    stmt -> location ASSIGNOP expr
Rule 27    stmt -> RETURN expr
Rule 28    stmt -> SKIP
Rule 29    stmt -> BEGIN stmtlist END
Rule 30    stmt -> instr_open
Rule 31    stmt -> instr_rel
Rule 32    stmt -> BREAK
Rule 33    stmt -> WHILE relation DO stmt
Rule 34    stmt -> READ ( location )
Rule 35    stmt -> WRITE ( expr )
Rule 36    stmt -> PRINT ( literal )
Rule 37    instr_open -> IF relation THEN stmt ELSE stmt  [precedence=left, level=2]
Rule 38    instr_rel -> IF relation THEN stmt  [precedence=left, level=1]
Rule 39    literal -> STRING
Rule 40    location -> ID [ expr ]
Rule 41    location -> ID
Rule 42    expr -> FLOAT ( expr )
Rule 43    expr -> INT ( expr )
Rule 44    expr -> ID ( _4_exprlist_optional )
Rule 45    _4_exprlist_optional -> exprlist
Rule 46    _4_exprlist_optional -> <empty>
Rule 47    expr -> ID [ expr ]
Rule 48    expr -> ID
Rule 49    expr -> FCONST
Rule 50    expr -> ICONST
Rule 51    expr -> ( expr )
Rule 52    expr -> + expr  [precedence=right, level=9]
Rule 53    expr -> - expr  [precedence=right, level=9]
Rule 54    expr -> expr / expr  [precedence=left, level=8]
Rule 55    expr -> expr * expr  [precedence=left, level=8]
Rule 56    expr -> expr - expr  [precedence=left, level=7]
Rule 57    expr -> expr + expr  [precedence=left, level=7]
Rule 58    relation -> ( relation )
Rule 59    relation -> NOT relation  [precedence=right, level=9]
Rule 60    relation -> relation OR relation  [precedence=left, level=3]
Rule 61    relation -> relation AND relation  [precedence=left, level=4]
Rule 62    relation -> expr DF expr  [precedence=left, level=5]
Rule 63    relation -> expr ET expr  [precedence=left, level=5]
Rule 64    relation -> expr GE expr  [precedence=left, level=6]
Rule 65    relation -> expr GT expr  [precedence=left, level=6]
Rule 66    relation -> expr LE expr  [precedence=left, level=6]
Rule 67    relation -> expr LT expr  [precedence=left, level=6]
Rule 68    exprlist -> expr
Rule 69    exprlist -> exprlist , expr

Terminals, with rules where they appear:

(                    : 4 23 34 35 36 42 43 44 51 58
)                    : 4 23 34 35 36 42 43 44 51 58
*                    : 55
+                    : 52 57
,                    : 10 69
-                    : 53 56
/                    : 54
:                    : 11 20
;                    : 16 17 21
AND                  : 61
ASSIGNOP             : 26
BEGIN                : 4 29
BREAK                : 32
DF                   : 62
DO                   : 33
ELSE                 : 37
END                  : 4 29
ET                   : 63
FCONST               : 49
FLOAT                : 12 14 42
FUN                  : 4
GE                   : 64
GT                   : 65
ICONST               : 50
ID                   : 4 11 20 23 40 41 44 47 48
IF                   : 37 38
INT                  : 13 15 43
LE                   : 66
LT                   : 67
NOT                  : 59
OR                   : 60
PRINT                : 36
READ                 : 34
RETURN               : 27
SKIP                 : 28
STRING               : 39
THEN                 : 37 38
WHILE                : 33
WRITE                : 35
[                    : 14 15 40 47
]                    : 14 15 40 47
error                : 

Nonterminals, with rules where they appear:

_1_parmlist_optional : 4
_2_locallist_optional : 4
_3_exprlist_optional : 23
_4_exprlist_optional : 44
datatype             : 11 20
expr                 : 14 15 26 27 35 40 42 43 47 51 52 53 54 54 55 55 56 56 57 57 62 62 63 63 64 64 65 65 66 66 67 67 68 69
exprlist             : 24 45 69
func                 : 2 3 18
funclist             : 1 3
instr_open           : 30
instr_rel            : 31
literal              : 36
local                : 16 17
locallist            : 7 16
location             : 26 34
parm                 : 9 10
parmlist             : 5 10
program              : 0
relation             : 33 37 38 58 59 60 60 61 61
stmt                 : 21 22 33 37 37 38
stmtlist             : 4 21 29
vardecl              : 19


state 0

    (0) S' -> . program
    (1) program -> . funclist
    (2) funclist -> . func
    (3) funclist -> . funclist func
    (4) func -> . FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END
    FUN             shift and go to state 4

    program                        shift and go to state 1
    funclist                       shift and go to state 2
    func                           shift and go to state 3

state 1

    (0) S' -> program .


state 2

    (1) program -> funclist .
    (3) funclist -> funclist . func
    (4) func -> . FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END
    $end            reduce using rule 1 (program -> funclist .)
    FUN             shift and go to state 4

    func                           shift and go to state 5

state 3

    (2) funclist -> func .
    FUN             reduce using rule 2 (funclist -> func .)
    $end            reduce using rule 2 (funclist -> func .)


state 4

    (4) func -> FUN . ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END
    ID              shift and go to state 6


state 5

    (3) funclist -> funclist func .
    FUN             reduce using rule 3 (funclist -> funclist func .)
    $end            reduce using rule 3 (funclist -> funclist func .)


state 6

    (4) func -> FUN ID . ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END
    (               shift and go to state 7


state 7

    (4) func -> FUN ID ( . _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END
    (5) _1_parmlist_optional -> . parmlist
    (6) _1_parmlist_optional -> .
    (9) parmlist -> . parm
    (10) parmlist -> . parmlist , parm
    (11) parm -> . ID : datatype
    )               reduce using rule 6 (_1_parmlist_optional -> .)
    ID              shift and go to state 8

    _1_parmlist_optional           shift and go to state 9
    parmlist                       shift and go to state 10
    parm                           shift and go to state 11

state 8

    (11) parm -> ID . : datatype
    :               shift and go to state 12


state 9

    (4) func -> FUN ID ( _1_parmlist_optional . ) _2_locallist_optional BEGIN stmtlist END
    )               shift and go to state 13


state 10

    (5) _1_parmlist_optional -> parmlist .
    (10) parmlist -> parmlist . , parm
    )               reduce using rule 5 (_1_parmlist_optional -> parmlist .)
    ,               shift and go to state 14


state 11

    (9) parmlist -> parm .
    ,               reduce using rule 9 (parmlist -> parm .)
    )               reduce using rule 9 (parmlist -> parm .)


state 12

    (11) parm -> ID : . datatype
    (12) datatype -> . FLOAT
    (13) datatype -> . INT
    (14) datatype -> . FLOAT [ expr ]
    (15) datatype -> . INT [ expr ]
    FLOAT           shift and go to state 16
    INT             shift and go to state 17

    datatype                       shift and go to state 15

state 13

    (4) func -> FUN ID ( _1_parmlist_optional ) . _2_locallist_optional BEGIN stmtlist END
    (7) _2_locallist_optional -> . locallist
    (8) _2_locallist_optional -> .
    (16) locallist -> . local ; locallist
    (17) locallist -> . local ;
    (18) local -> . func
    (19) local -> . vardecl
    (4) func -> . FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END
    (20) vardecl -> . ID : datatype
    BEGIN           reduce using rule 8 (_2_locallist_optional -> .)
    FUN             shift and go to state 4
    ID              shift and go to state 18

    _2_locallist_optional          shift and go to state 19
    locallist                      shift and go to state 20
    local                          shift and go to state 21
    func                           shift and go to state 22
    vardecl                        shift and go to state 23

state 14

    (10) parmlist -> parmlist , . parm
    (11) parm -> . ID : datatype
    ID              shift and go to state 8

    parm                           shift and go to state 24

state 15

    (11) parm -> ID : datatype .
    ,               reduce using rule 11 (parm -> ID : datatype .)
    )               reduce using rule 11 (parm -> ID : datatype .)


state 16

    (12) datatype -> FLOAT .
    (14) datatype -> FLOAT . [ expr ]
    ,               reduce using rule 12 (datatype -> FLOAT .)
    )               reduce using rule 12 (datatype -> FLOAT .)
    ;               reduce using rule 12 (datatype -> FLOAT .)
    [               shift and go to state 25


state 17

    (13) datatype -> INT .
    (15) datatype -> INT . [ expr ]
    ,               reduce using rule 13 (datatype -> INT .)
    )               reduce using rule 13 (datatype -> INT .)
    ;               reduce using rule 13 (datatype -> INT .)
    [               shift and go to state 26


state 18

    (20) vardecl -> ID . : datatype
    :               shift and go to state 27


state 19

    (4) func -> FUN ID ( _1_parmlist_optional ) _2_locallist_optional . BEGIN stmtlist END
    BEGIN           shift and go to state 28


state 20

    (7) _2_locallist_optional -> locallist .
    BEGIN           reduce using rule 7 (_2_locallist_optional -> locallist .)


state 21

    (16) locallist -> local . ; locallist
    (17) locallist -> local . ;
    ;               shift and go to state 29


state 22

    (18) local -> func .
    ;               reduce using rule 18 (local -> func .)


state 23

    (19) local -> vardecl .
    ;               reduce using rule 19 (local -> vardecl .)


state 24

    (10) parmlist -> parmlist , parm .
    ,               reduce using rule 10 (parmlist -> parmlist , parm .)
    )               reduce using rule 10 (parmlist -> parmlist , parm .)


state 25

    (14) datatype -> FLOAT [ . expr ]
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 31

state 26

    (15) datatype -> INT [ . expr ]
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 39

state 27

    (20) vardecl -> ID : . datatype
    (12) datatype -> . FLOAT
    (13) datatype -> . INT
    (14) datatype -> . FLOAT [ expr ]
    (15) datatype -> . INT [ expr ]
    FLOAT           shift and go to state 16
    INT             shift and go to state 17

    datatype                       shift and go to state 40

state 28

    (4) func -> FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN . stmtlist END
    (21) stmtlist -> . stmt ; stmtlist
    (22) stmtlist -> . stmt
    (23) stmt -> . ID ( _3_exprlist_optional )
    (26) stmt -> . location ASSIGNOP expr
    (27) stmt -> . RETURN expr
    (28) stmt -> . SKIP
    (29) stmt -> . BEGIN stmtlist END
    (30) stmt -> . instr_open
    (31) stmt -> . instr_rel
    (32) stmt -> . BREAK
    (33) stmt -> . WHILE relation DO stmt
    (34) stmt -> . READ ( location )
    (35) stmt -> . WRITE ( expr )
    (36) stmt -> . PRINT ( literal )
    (40) location -> . ID [ expr ]
    (41) location -> . ID
    (37) instr_open -> . IF relation THEN stmt ELSE stmt
    (38) instr_rel -> . IF relation THEN stmt
    ID              shift and go to state 41
    RETURN          shift and go to state 46
    SKIP            shift and go to state 47
    BEGIN           shift and go to state 42
    BREAK           shift and go to state 50
    WHILE           shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    PRINT           shift and go to state 54
    IF              shift and go to state 55

    stmtlist                       shift and go to state 43
    stmt                           shift and go to state 44
    location                       shift and go to state 45
    instr_open                     shift and go to state 48
    instr_rel                      shift and go to state 49

state 29

    (16) locallist -> local ; . locallist
    (17) locallist -> local ; .
    (16) locallist -> . local ; locallist
    (17) locallist -> . local ;
    (18) local -> . func
    (19) local -> . vardecl
    (4) func -> . FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END
    (20) vardecl -> . ID : datatype
    BEGIN           reduce using rule 17 (locallist -> local ; .)
    FUN             shift and go to state 4
    ID              shift and go to state 18

    local                          shift and go to state 21
    locallist                      shift and go to state 56
    func                           shift and go to state 22
    vardecl                        shift and go to state 23

state 30

    (42) expr -> FLOAT . ( expr )
    (               shift and go to state 57


state 31

    (14) datatype -> FLOAT [ expr . ]
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 32

    (51) expr -> ( . expr )
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 63

state 33

    (43) expr -> INT . ( expr )
    (               shift and go to state 64


state 34

    (44) expr -> ID . ( _4_exprlist_optional )
    (47) expr -> ID . [ expr ]
    (48) expr -> ID .
    (               shift and go to state 65
    [               shift and go to state 66
    ]               reduce using rule 48 (expr -> ID .)
    /               reduce using rule 48 (expr -> ID .)
    *               reduce using rule 48 (expr -> ID .)
    -               reduce using rule 48 (expr -> ID .)
    +               reduce using rule 48 (expr -> ID .)
    )               reduce using rule 48 (expr -> ID .)
    ;               reduce using rule 48 (expr -> ID .)
    END             reduce using rule 48 (expr -> ID .)
    ELSE            reduce using rule 48 (expr -> ID .)
    DF              reduce using rule 48 (expr -> ID .)
    ET              reduce using rule 48 (expr -> ID .)
    GE              reduce using rule 48 (expr -> ID .)
    GT              reduce using rule 48 (expr -> ID .)
    LE              reduce using rule 48 (expr -> ID .)
    LT              reduce using rule 48 (expr -> ID .)
    ,               reduce using rule 48 (expr -> ID .)
    DO              reduce using rule 48 (expr -> ID .)
    OR              reduce using rule 48 (expr -> ID .)
    AND             reduce using rule 48 (expr -> ID .)
    THEN            reduce using rule 48 (expr -> ID .)


state 35

    (49) expr -> FCONST .
    ]               reduce using rule 49 (expr -> FCONST .)
    /               reduce using rule 49 (expr -> FCONST .)
    *               reduce using rule 49 (expr -> FCONST .)
    -               reduce using rule 49 (expr -> FCONST .)
    +               reduce using rule 49 (expr -> FCONST .)
    )               reduce using rule 49 (expr -> FCONST .)
    ;               reduce using rule 49 (expr -> FCONST .)
    END             reduce using rule 49 (expr -> FCONST .)
    ELSE            reduce using rule 49 (expr -> FCONST .)
    DF              reduce using rule 49 (expr -> FCONST .)
    ET              reduce using rule 49 (expr -> FCONST .)
    GE              reduce using rule 49 (expr -> FCONST .)
    GT              reduce using rule 49 (expr -> FCONST .)
    LE              reduce using rule 49 (expr -> FCONST .)
    LT              reduce using rule 49 (expr -> FCONST .)
    ,               reduce using rule 49 (expr -> FCONST .)
    DO              reduce using rule 49 (expr -> FCONST .)
    OR              reduce using rule 49 (expr -> FCONST .)
    AND             reduce using rule 49 (expr -> FCONST .)
    THEN            reduce using rule 49 (expr -> FCONST .)


state 36

    (50) expr -> ICONST .
    ]               reduce using rule 50 (expr -> ICONST .)
    /               reduce using rule 50 (expr -> ICONST .)
    *               reduce using rule 50 (expr -> ICONST .)
    -               reduce using rule 50 (expr -> ICONST .)
    +               reduce using rule 50 (expr -> ICONST .)
    )               reduce using rule 50 (expr -> ICONST .)
    ;               reduce using rule 50 (expr -> ICONST .)
    END             reduce using rule 50 (expr -> ICONST .)
    ELSE            reduce using rule 50 (expr -> ICONST .)
    DF              reduce using rule 50 (expr -> ICONST .)
    ET              reduce using rule 50 (expr -> ICONST .)
    GE              reduce using rule 50 (expr -> ICONST .)
    GT              reduce using rule 50 (expr -> ICONST .)
    LE              reduce using rule 50 (expr -> ICONST .)
    LT              reduce using rule 50 (expr -> ICONST .)
    ,               reduce using rule 50 (expr -> ICONST .)
    DO              reduce using rule 50 (expr -> ICONST .)
    OR              reduce using rule 50 (expr -> ICONST .)
    AND             reduce using rule 50 (expr -> ICONST .)
    THEN            reduce using rule 50 (expr -> ICONST .)


state 37

    (52) expr -> + . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 67

state 38

    (53) expr -> - . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 68

state 39

    (15) datatype -> INT [ expr . ]
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               shift and go to state 69
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 40

    (20) vardecl -> ID : datatype .
    ;               reduce using rule 20 (vardecl -> ID : datatype .)


state 41

    (23) stmt -> ID . ( _3_exprlist_optional )
    (40) location -> ID . [ expr ]
    (41) location -> ID .
    (               shift and go to state 70
    [               shift and go to state 71
    ASSIGNOP        reduce using rule 41 (location -> ID .)


state 42

    (29) stmt -> BEGIN . stmtlist END
    (21) stmtlist -> . stmt ; stmtlist
    (22) stmtlist -> . stmt
    (23) stmt -> . ID ( _3_exprlist_optional )
    (26) stmt -> . location ASSIGNOP expr
    (27) stmt -> . RETURN expr
    (28) stmt -> . SKIP
    (29) stmt -> . BEGIN stmtlist END
    (30) stmt -> . instr_open
    (31) stmt -> . instr_rel
    (32) stmt -> . BREAK
    (33) stmt -> . WHILE relation DO stmt
    (34) stmt -> . READ ( location )
    (35) stmt -> . WRITE ( expr )
    (36) stmt -> . PRINT ( literal )
    (40) location -> . ID [ expr ]
    (41) location -> . ID
    (37) instr_open -> . IF relation THEN stmt ELSE stmt
    (38) instr_rel -> . IF relation THEN stmt
    ID              shift and go to state 41
    RETURN          shift and go to state 46
    SKIP            shift and go to state 47
    BEGIN           shift and go to state 42
    BREAK           shift and go to state 50
    WHILE           shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    PRINT           shift and go to state 54
    IF              shift and go to state 55

    stmtlist                       shift and go to state 72
    stmt                           shift and go to state 44
    location                       shift and go to state 45
    instr_open                     shift and go to state 48
    instr_rel                      shift and go to state 49

state 43

    (4) func -> FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist . END
    END             shift and go to state 73


state 44

    (21) stmtlist -> stmt . ; stmtlist
    (22) stmtlist -> stmt .
    ;               shift and go to state 74
    END             reduce using rule 22 (stmtlist -> stmt .)


state 45

    (26) stmt -> location . ASSIGNOP expr
    ASSIGNOP        shift and go to state 75


state 46

    (27) stmt -> RETURN . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 76

state 47

    (28) stmt -> SKIP .
    ;               reduce using rule 28 (stmt -> SKIP .)
    END             reduce using rule 28 (stmt -> SKIP .)
    ELSE            reduce using rule 28 (stmt -> SKIP .)


state 48

    (30) stmt -> instr_open .
    ;               reduce using rule 30 (stmt -> instr_open .)
    END             reduce using rule 30 (stmt -> instr_open .)
    ELSE            reduce using rule 30 (stmt -> instr_open .)


state 49

    (31) stmt -> instr_rel .
    ;               reduce using rule 31 (stmt -> instr_rel .)
    END             reduce using rule 31 (stmt -> instr_rel .)
    ELSE            reduce using rule 31 (stmt -> instr_rel .)


state 50

    (32) stmt -> BREAK .
    ;               reduce using rule 32 (stmt -> BREAK .)
    END             reduce using rule 32 (stmt -> BREAK .)
    ELSE            reduce using rule 32 (stmt -> BREAK .)


state 51

    (33) stmt -> WHILE . relation DO stmt
    (58) relation -> . ( relation )
    (59) relation -> . NOT relation
    (60) relation -> . relation OR relation
    (61) relation -> . relation AND relation
    (62) relation -> . expr DF expr
    (63) relation -> . expr ET expr
    (64) relation -> . expr GE expr
    (65) relation -> . expr GT expr
    (66) relation -> . expr LE expr
    (67) relation -> . expr LT expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    (               shift and go to state 78
    NOT             shift and go to state 79
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38

    relation                       shift and go to state 77
    expr                           shift and go to state 80

state 52

    (34) stmt -> READ . ( location )
    (               shift and go to state 81


state 53

    (35) stmt -> WRITE . ( expr )
    (               shift and go to state 82


state 54

    (36) stmt -> PRINT . ( literal )
    (               shift and go to state 83


state 55

    (37) instr_open -> IF . relation THEN stmt ELSE stmt
    (38) instr_rel -> IF . relation THEN stmt
    (58) relation -> . ( relation )
    (59) relation -> . NOT relation
    (60) relation -> . relation OR relation
    (61) relation -> . relation AND relation
    (62) relation -> . expr DF expr
    (63) relation -> . expr ET expr
    (64) relation -> . expr GE expr
    (65) relation -> . expr GT expr
    (66) relation -> . expr LE expr
    (67) relation -> . expr LT expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    (               shift and go to state 78
    NOT             shift and go to state 79
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38

    relation                       shift and go to state 84
    expr                           shift and go to state 80

state 56

    (16) locallist -> local ; locallist .
    BEGIN           reduce using rule 16 (locallist -> local ; locallist .)


state 57

    (42) expr -> FLOAT ( . expr )
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 85

state 58

    (14) datatype -> FLOAT [ expr ] .
    ,               reduce using rule 14 (datatype -> FLOAT [ expr ] .)
    )               reduce using rule 14 (datatype -> FLOAT [ expr ] .)
    ;               reduce using rule 14 (datatype -> FLOAT [ expr ] .)


state 59

    (54) expr -> expr / . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 86

state 60

    (55) expr -> expr * . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 87

state 61

    (56) expr -> expr - . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 88

state 62

    (57) expr -> expr + . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 89

state 63

    (51) expr -> ( expr . )
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    )               shift and go to state 90
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 64

    (43) expr -> INT ( . expr )
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 91

state 65

    (44) expr -> ID ( . _4_exprlist_optional )
    (45) _4_exprlist_optional -> . exprlist
    (46) _4_exprlist_optional -> .
    (68) exprlist -> . expr
    (69) exprlist -> . exprlist , expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    )               reduce using rule 46 (_4_exprlist_optional -> .)
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    _4_exprlist_optional           shift and go to state 92
    exprlist                       shift and go to state 93
    expr                           shift and go to state 94

state 66

    (47) expr -> ID [ . expr ]
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 95

state 67

    (52) expr -> + expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               reduce using rule 52 (expr -> + expr .)
    /               reduce using rule 52 (expr -> + expr .)
    *               reduce using rule 52 (expr -> + expr .)
    -               reduce using rule 52 (expr -> + expr .)
    +               reduce using rule 52 (expr -> + expr .)
    )               reduce using rule 52 (expr -> + expr .)
    ;               reduce using rule 52 (expr -> + expr .)
    END             reduce using rule 52 (expr -> + expr .)
    ELSE            reduce using rule 52 (expr -> + expr .)
    DF              reduce using rule 52 (expr -> + expr .)
    ET              reduce using rule 52 (expr -> + expr .)
    GE              reduce using rule 52 (expr -> + expr .)
    GT              reduce using rule 52 (expr -> + expr .)
    LE              reduce using rule 52 (expr -> + expr .)
    LT              reduce using rule 52 (expr -> + expr .)
    ,               reduce using rule 52 (expr -> + expr .)
    DO              reduce using rule 52 (expr -> + expr .)
    OR              reduce using rule 52 (expr -> + expr .)
    AND             reduce using rule 52 (expr -> + expr .)
    THEN            reduce using rule 52 (expr -> + expr .)


state 68

    (53) expr -> - expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               reduce using rule 53 (expr -> - expr .)
    /               reduce using rule 53 (expr -> - expr .)
    *               reduce using rule 53 (expr -> - expr .)
    -               reduce using rule 53 (expr -> - expr .)
    +               reduce using rule 53 (expr -> - expr .)
    )               reduce using rule 53 (expr -> - expr .)
    ;               reduce using rule 53 (expr -> - expr .)
    END             reduce using rule 53 (expr -> - expr .)
    ELSE            reduce using rule 53 (expr -> - expr .)
    DF              reduce using rule 53 (expr -> - expr .)
    ET              reduce using rule 53 (expr -> - expr .)
    GE              reduce using rule 53 (expr -> - expr .)
    GT              reduce using rule 53 (expr -> - expr .)
    LE              reduce using rule 53 (expr -> - expr .)
    LT              reduce using rule 53 (expr -> - expr .)
    ,               reduce using rule 53 (expr -> - expr .)
    DO              reduce using rule 53 (expr -> - expr .)
    OR              reduce using rule 53 (expr -> - expr .)
    AND             reduce using rule 53 (expr -> - expr .)
    THEN            reduce using rule 53 (expr -> - expr .)


state 69

    (15) datatype -> INT [ expr ] .
    ,               reduce using rule 15 (datatype -> INT [ expr ] .)
    )               reduce using rule 15 (datatype -> INT [ expr ] .)
    ;               reduce using rule 15 (datatype -> INT [ expr ] .)


state 70

    (23) stmt -> ID ( . _3_exprlist_optional )
    (24) _3_exprlist_optional -> . exprlist
    (25) _3_exprlist_optional -> .
    (68) exprlist -> . expr
    (69) exprlist -> . exprlist , expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    )               reduce using rule 25 (_3_exprlist_optional -> .)
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    _3_exprlist_optional           shift and go to state 96
    exprlist                       shift and go to state 97
    expr                           shift and go to state 94

state 71

    (40) location -> ID [ . expr ]
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 98

state 72

    (29) stmt -> BEGIN stmtlist . END
    END             shift and go to state 99


state 73

    (4) func -> FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END .
    FUN             reduce using rule 4 (func -> FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END .)
    $end            reduce using rule 4 (func -> FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END .)
    ;               reduce using rule 4 (func -> FUN ID ( _1_parmlist_optional ) _2_locallist_optional BEGIN stmtlist END .)


state 74

    (21) stmtlist -> stmt ; . stmtlist
    (21) stmtlist -> . stmt ; stmtlist
    (22) stmtlist -> . stmt
    (23) stmt -> . ID ( _3_exprlist_optional )
    (26) stmt -> . location ASSIGNOP expr
    (27) stmt -> . RETURN expr
    (28) stmt -> . SKIP
    (29) stmt -> . BEGIN stmtlist END
    (30) stmt -> . instr_open
    (31) stmt -> . instr_rel
    (32) stmt -> . BREAK
    (33) stmt -> . WHILE relation DO stmt
    (34) stmt -> . READ ( location )
    (35) stmt -> . WRITE ( expr )
    (36) stmt -> . PRINT ( literal )
    (40) location -> . ID [ expr ]
    (41) location -> . ID
    (37) instr_open -> . IF relation THEN stmt ELSE stmt
    (38) instr_rel -> . IF relation THEN stmt
    ID              shift and go to state 41
    RETURN          shift and go to state 46
    SKIP            shift and go to state 47
    BEGIN           shift and go to state 42
    BREAK           shift and go to state 50
    WHILE           shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    PRINT           shift and go to state 54
    IF              shift and go to state 55

    stmt                           shift and go to state 44
    stmtlist                       shift and go to state 100
    location                       shift and go to state 45
    instr_open                     shift and go to state 48
    instr_rel                      shift and go to state 49

state 75

    (26) stmt -> location ASSIGNOP . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 101

state 76

    (27) stmt -> RETURN expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ;               reduce using rule 27 (stmt -> RETURN expr .)
    END             reduce using rule 27 (stmt -> RETURN expr .)
    ELSE            reduce using rule 27 (stmt -> RETURN expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 77

    (33) stmt -> WHILE relation . DO stmt
    (60) relation -> relation . OR relation
    (61) relation -> relation . AND relation
    DO              shift and go to state 102
    OR              shift and go to state 103
    AND             shift and go to state 104


state 78

    (58) relation -> ( . relation )
    (51) expr -> ( . expr )
    (58) relation -> . ( relation )
    (59) relation -> . NOT relation
    (60) relation -> . relation OR relation
    (61) relation -> . relation AND relation
    (62) relation -> . expr DF expr
    (63) relation -> . expr ET expr
    (64) relation -> . expr GE expr
    (65) relation -> . expr GT expr
    (66) relation -> . expr LE expr
    (67) relation -> . expr LT expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    (               shift and go to state 78
    NOT             shift and go to state 79
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38

    relation                       shift and go to state 105
    expr                           shift and go to state 106

state 79

    (59) relation -> NOT . relation
    (58) relation -> . ( relation )
    (59) relation -> . NOT relation
    (60) relation -> . relation OR relation
    (61) relation -> . relation AND relation
    (62) relation -> . expr DF expr
    (63) relation -> . expr ET expr
    (64) relation -> . expr GE expr
    (65) relation -> . expr GT expr
    (66) relation -> . expr LE expr
    (67) relation -> . expr LT expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    (               shift and go to state 78
    NOT             shift and go to state 79
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38

    relation                       shift and go to state 107
    expr                           shift and go to state 80

state 80

    (62) relation -> expr . DF expr
    (63) relation -> expr . ET expr
    (64) relation -> expr . GE expr
    (65) relation -> expr . GT expr
    (66) relation -> expr . LE expr
    (67) relation -> expr . LT expr
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    DF              shift and go to state 108
    ET              shift and go to state 109
    GE              shift and go to state 110
    GT              shift and go to state 111
    LE              shift and go to state 112
    LT              shift and go to state 113
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 81

    (34) stmt -> READ ( . location )
    (40) location -> . ID [ expr ]
    (41) location -> . ID
    ID              shift and go to state 115

    location                       shift and go to state 114

state 82

    (35) stmt -> WRITE ( . expr )
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 116

state 83

    (36) stmt -> PRINT ( . literal )
    (39) literal -> . STRING
    STRING          shift and go to state 118

    literal                        shift and go to state 117

state 84

    (37) instr_open -> IF relation . THEN stmt ELSE stmt
    (38) instr_rel -> IF relation . THEN stmt
    (60) relation -> relation . OR relation
    (61) relation -> relation . AND relation
    THEN            shift and go to state 119
    OR              shift and go to state 103
    AND             shift and go to state 104


state 85

    (42) expr -> FLOAT ( expr . )
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    )               shift and go to state 120
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 86

    (54) expr -> expr / expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               reduce using rule 54 (expr -> expr / expr .)
    /               reduce using rule 54 (expr -> expr / expr .)
    *               reduce using rule 54 (expr -> expr / expr .)
    -               reduce using rule 54 (expr -> expr / expr .)
    +               reduce using rule 54 (expr -> expr / expr .)
    )               reduce using rule 54 (expr -> expr / expr .)
    ;               reduce using rule 54 (expr -> expr / expr .)
    END             reduce using rule 54 (expr -> expr / expr .)
    ELSE            reduce using rule 54 (expr -> expr / expr .)
    DF              reduce using rule 54 (expr -> expr / expr .)
    ET              reduce using rule 54 (expr -> expr / expr .)
    GE              reduce using rule 54 (expr -> expr / expr .)
    GT              reduce using rule 54 (expr -> expr / expr .)
    LE              reduce using rule 54 (expr -> expr / expr .)
    LT              reduce using rule 54 (expr -> expr / expr .)
    ,               reduce using rule 54 (expr -> expr / expr .)
    DO              reduce using rule 54 (expr -> expr / expr .)
    OR              reduce using rule 54 (expr -> expr / expr .)
    AND             reduce using rule 54 (expr -> expr / expr .)
    THEN            reduce using rule 54 (expr -> expr / expr .)


state 87

    (55) expr -> expr * expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               reduce using rule 55 (expr -> expr * expr .)
    /               reduce using rule 55 (expr -> expr * expr .)
    *               reduce using rule 55 (expr -> expr * expr .)
    -               reduce using rule 55 (expr -> expr * expr .)
    +               reduce using rule 55 (expr -> expr * expr .)
    )               reduce using rule 55 (expr -> expr * expr .)
    ;               reduce using rule 55 (expr -> expr * expr .)
    END             reduce using rule 55 (expr -> expr * expr .)
    ELSE            reduce using rule 55 (expr -> expr * expr .)
    DF              reduce using rule 55 (expr -> expr * expr .)
    ET              reduce using rule 55 (expr -> expr * expr .)
    GE              reduce using rule 55 (expr -> expr * expr .)
    GT              reduce using rule 55 (expr -> expr * expr .)
    LE              reduce using rule 55 (expr -> expr * expr .)
    LT              reduce using rule 55 (expr -> expr * expr .)
    ,               reduce using rule 55 (expr -> expr * expr .)
    DO              reduce using rule 55 (expr -> expr * expr .)
    OR              reduce using rule 55 (expr -> expr * expr .)
    AND             reduce using rule 55 (expr -> expr * expr .)
    THEN            reduce using rule 55 (expr -> expr * expr .)


state 88

    (56) expr -> expr - expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               reduce using rule 56 (expr -> expr - expr .)
    -               reduce using rule 56 (expr -> expr - expr .)
    +               reduce using rule 56 (expr -> expr - expr .)
    )               reduce using rule 56 (expr -> expr - expr .)
    ;               reduce using rule 56 (expr -> expr - expr .)
    END             reduce using rule 56 (expr -> expr - expr .)
    ELSE            reduce using rule 56 (expr -> expr - expr .)
    DF              reduce using rule 56 (expr -> expr - expr .)
    ET              reduce using rule 56 (expr -> expr - expr .)
    GE              reduce using rule 56 (expr -> expr - expr .)
    GT              reduce using rule 56 (expr -> expr - expr .)
    LE              reduce using rule 56 (expr -> expr - expr .)
    LT              reduce using rule 56 (expr -> expr - expr .)
    ,               reduce using rule 56 (expr -> expr - expr .)
    DO              reduce using rule 56 (expr -> expr - expr .)
    OR              reduce using rule 56 (expr -> expr - expr .)
    AND             reduce using rule 56 (expr -> expr - expr .)
    THEN            reduce using rule 56 (expr -> expr - expr .)
    /               shift and go to state 59
    *               shift and go to state 60


state 89

    (57) expr -> expr + expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               reduce using rule 57 (expr -> expr + expr .)
    -               reduce using rule 57 (expr -> expr + expr .)
    +               reduce using rule 57 (expr -> expr + expr .)
    )               reduce using rule 57 (expr -> expr + expr .)
    ;               reduce using rule 57 (expr -> expr + expr .)
    END             reduce using rule 57 (expr -> expr + expr .)
    ELSE            reduce using rule 57 (expr -> expr + expr .)
    DF              reduce using rule 57 (expr -> expr + expr .)
    ET              reduce using rule 57 (expr -> expr + expr .)
    GE              reduce using rule 57 (expr -> expr + expr .)
    GT              reduce using rule 57 (expr -> expr + expr .)
    LE              reduce using rule 57 (expr -> expr + expr .)
    LT              reduce using rule 57 (expr -> expr + expr .)
    ,               reduce using rule 57 (expr -> expr + expr .)
    DO              reduce using rule 57 (expr -> expr + expr .)
    OR              reduce using rule 57 (expr -> expr + expr .)
    AND             reduce using rule 57 (expr -> expr + expr .)
    THEN            reduce using rule 57 (expr -> expr + expr .)
    /               shift and go to state 59
    *               shift and go to state 60


state 90

    (51) expr -> ( expr ) .
    ]               reduce using rule 51 (expr -> ( expr ) .)
    /               reduce using rule 51 (expr -> ( expr ) .)
    *               reduce using rule 51 (expr -> ( expr ) .)
    -               reduce using rule 51 (expr -> ( expr ) .)
    +               reduce using rule 51 (expr -> ( expr ) .)
    )               reduce using rule 51 (expr -> ( expr ) .)
    ;               reduce using rule 51 (expr -> ( expr ) .)
    END             reduce using rule 51 (expr -> ( expr ) .)
    ELSE            reduce using rule 51 (expr -> ( expr ) .)
    DF              reduce using rule 51 (expr -> ( expr ) .)
    ET              reduce using rule 51 (expr -> ( expr ) .)
    GE              reduce using rule 51 (expr -> ( expr ) .)
    GT              reduce using rule 51 (expr -> ( expr ) .)
    LE              reduce using rule 51 (expr -> ( expr ) .)
    LT              reduce using rule 51 (expr -> ( expr ) .)
    ,               reduce using rule 51 (expr -> ( expr ) .)
    DO              reduce using rule 51 (expr -> ( expr ) .)
    OR              reduce using rule 51 (expr -> ( expr ) .)
    AND             reduce using rule 51 (expr -> ( expr ) .)
    THEN            reduce using rule 51 (expr -> ( expr ) .)


state 91

    (43) expr -> INT ( expr . )
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    )               shift and go to state 121
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 92

    (44) expr -> ID ( _4_exprlist_optional . )
    )               shift and go to state 122


state 93

    (45) _4_exprlist_optional -> exprlist .
    (69) exprlist -> exprlist . , expr
    )               reduce using rule 45 (_4_exprlist_optional -> exprlist .)
    ,               shift and go to state 123


state 94

    (68) exprlist -> expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ,               reduce using rule 68 (exprlist -> expr .)
    )               reduce using rule 68 (exprlist -> expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 95

    (47) expr -> ID [ expr . ]
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               shift and go to state 124
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 96

    (23) stmt -> ID ( _3_exprlist_optional . )
    )               shift and go to state 125


state 97

    (24) _3_exprlist_optional -> exprlist .
    (69) exprlist -> exprlist . , expr
    )               reduce using rule 24 (_3_exprlist_optional -> exprlist .)
    ,               shift and go to state 123


state 98

    (40) location -> ID [ expr . ]
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ]               shift and go to state 126
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 99

    (29) stmt -> BEGIN stmtlist END .
    ;               reduce using rule 29 (stmt -> BEGIN stmtlist END .)
    END             reduce using rule 29 (stmt -> BEGIN stmtlist END .)
    ELSE            reduce using rule 29 (stmt -> BEGIN stmtlist END .)


state 100

    (21) stmtlist -> stmt ; stmtlist .
    END             reduce using rule 21 (stmtlist -> stmt ; stmtlist .)


state 101

    (26) stmt -> location ASSIGNOP expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ;               reduce using rule 26 (stmt -> location ASSIGNOP expr .)
    END             reduce using rule 26 (stmt -> location ASSIGNOP expr .)
    ELSE            reduce using rule 26 (stmt -> location ASSIGNOP expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 102

    (33) stmt -> WHILE relation DO . stmt
    (23) stmt -> . ID ( _3_exprlist_optional )
    (26) stmt -> . location ASSIGNOP expr
    (27) stmt -> . RETURN expr
    (28) stmt -> . SKIP
    (29) stmt -> . BEGIN stmtlist END
    (30) stmt -> . instr_open
    (31) stmt -> . instr_rel
    (32) stmt -> . BREAK
    (33) stmt -> . WHILE relation DO stmt
    (34) stmt -> . READ ( location )
    (35) stmt -> . WRITE ( expr )
    (36) stmt -> . PRINT ( literal )
    (40) location -> . ID [ expr ]
    (41) location -> . ID
    (37) instr_open -> . IF relation THEN stmt ELSE stmt
    (38) instr_rel -> . IF relation THEN stmt
    ID              shift and go to state 41
    RETURN          shift and go to state 46
    SKIP            shift and go to state 47
    BEGIN           shift and go to state 42
    BREAK           shift and go to state 50
    WHILE           shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    PRINT           shift and go to state 54
    IF              shift and go to state 55

    stmt                           shift and go to state 127
    location                       shift and go to state 45
    instr_open                     shift and go to state 48
    instr_rel                      shift and go to state 49

state 103

    (60) relation -> relation OR . relation
    (58) relation -> . ( relation )
    (59) relation -> . NOT relation
    (60) relation -> . relation OR relation
    (61) relation -> . relation AND relation
    (62) relation -> . expr DF expr
    (63) relation -> . expr ET expr
    (64) relation -> . expr GE expr
    (65) relation -> . expr GT expr
    (66) relation -> . expr LE expr
    (67) relation -> . expr LT expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    (               shift and go to state 78
    NOT             shift and go to state 79
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38

    relation                       shift and go to state 128
    expr                           shift and go to state 80

state 104

    (61) relation -> relation AND . relation
    (58) relation -> . ( relation )
    (59) relation -> . NOT relation
    (60) relation -> . relation OR relation
    (61) relation -> . relation AND relation
    (62) relation -> . expr DF expr
    (63) relation -> . expr ET expr
    (64) relation -> . expr GE expr
    (65) relation -> . expr GT expr
    (66) relation -> . expr LE expr
    (67) relation -> . expr LT expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    (               shift and go to state 78
    NOT             shift and go to state 79
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38

    relation                       shift and go to state 129
    expr                           shift and go to state 80

state 105

    (58) relation -> ( relation . )
    (60) relation -> relation . OR relation
    (61) relation -> relation . AND relation
    )               shift and go to state 130
    OR              shift and go to state 103
    AND             shift and go to state 104


state 106

    (51) expr -> ( expr . )
    (62) relation -> expr . DF expr
    (63) relation -> expr . ET expr
    (64) relation -> expr . GE expr
    (65) relation -> expr . GT expr
    (66) relation -> expr . LE expr
    (67) relation -> expr . LT expr
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    )               shift and go to state 90
    DF              shift and go to state 108
    ET              shift and go to state 109
    GE              shift and go to state 110
    GT              shift and go to state 111
    LE              shift and go to state 112
    LT              shift and go to state 113
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 107

    (59) relation -> NOT relation .
    (60) relation -> relation . OR relation
    (61) relation -> relation . AND relation
    DO              reduce using rule 59 (relation -> NOT relation .)
    OR              reduce using rule 59 (relation -> NOT relation .)
    AND             reduce using rule 59 (relation -> NOT relation .)
    THEN            reduce using rule 59 (relation -> NOT relation .)
    )               reduce using rule 59 (relation -> NOT relation .)


state 108

    (62) relation -> expr DF . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 131

state 109

    (63) relation -> expr ET . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 132

state 110

    (64) relation -> expr GE . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 133

state 111

    (65) relation -> expr GT . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 134

state 112

    (66) relation -> expr LE . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 135

state 113

    (67) relation -> expr LT . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 136

state 114

    (34) stmt -> READ ( location . )
    )               shift and go to state 137


state 115

    (40) location -> ID . [ expr ]
    (41) location -> ID .
    [               shift and go to state 71
    )               reduce using rule 41 (location -> ID .)


state 116

    (35) stmt -> WRITE ( expr . )
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    )               shift and go to state 138
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 117

    (36) stmt -> PRINT ( literal . )
    )               shift and go to state 139


state 118

    (39) literal -> STRING .
    )               reduce using rule 39 (literal -> STRING .)


state 119

    (37) instr_open -> IF relation THEN . stmt ELSE stmt
    (38) instr_rel -> IF relation THEN . stmt
    (23) stmt -> . ID ( _3_exprlist_optional )
    (26) stmt -> . location ASSIGNOP expr
    (27) stmt -> . RETURN expr
    (28) stmt -> . SKIP
    (29) stmt -> . BEGIN stmtlist END
    (30) stmt -> . instr_open
    (31) stmt -> . instr_rel
    (32) stmt -> . BREAK
    (33) stmt -> . WHILE relation DO stmt
    (34) stmt -> . READ ( location )
    (35) stmt -> . WRITE ( expr )
    (36) stmt -> . PRINT ( literal )
    (40) location -> . ID [ expr ]
    (41) location -> . ID
    (37) instr_open -> . IF relation THEN stmt ELSE stmt
    (38) instr_rel -> . IF relation THEN stmt
    ID              shift and go to state 41
    RETURN          shift and go to state 46
    SKIP            shift and go to state 47
    BEGIN           shift and go to state 42
    BREAK           shift and go to state 50
    WHILE           shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    PRINT           shift and go to state 54
    IF              shift and go to state 55

    stmt                           shift and go to state 140
    location                       shift and go to state 45
    instr_open                     shift and go to state 48
    instr_rel                      shift and go to state 49

state 120

    (42) expr -> FLOAT ( expr ) .
    ]               reduce using rule 42 (expr -> FLOAT ( expr ) .)
    /               reduce using rule 42 (expr -> FLOAT ( expr ) .)
    *               reduce using rule 42 (expr -> FLOAT ( expr ) .)
    -               reduce using rule 42 (expr -> FLOAT ( expr ) .)
    +               reduce using rule 42 (expr -> FLOAT ( expr ) .)
    )               reduce using rule 42 (expr -> FLOAT ( expr ) .)
    ;               reduce using rule 42 (expr -> FLOAT ( expr ) .)
    END             reduce using rule 42 (expr -> FLOAT ( expr ) .)
    ELSE            reduce using rule 42 (expr -> FLOAT ( expr ) .)
    DF              reduce using rule 42 (expr -> FLOAT ( expr ) .)
    ET              reduce using rule 42 (expr -> FLOAT ( expr ) .)
    GE              reduce using rule 42 (expr -> FLOAT ( expr ) .)
    GT              reduce using rule 42 (expr -> FLOAT ( expr ) .)
    LE              reduce using rule 42 (expr -> FLOAT ( expr ) .)
    LT              reduce using rule 42 (expr -> FLOAT ( expr ) .)
    ,               reduce using rule 42 (expr -> FLOAT ( expr ) .)
    DO              reduce using rule 42 (expr -> FLOAT ( expr ) .)
    OR              reduce using rule 42 (expr -> FLOAT ( expr ) .)
    AND             reduce using rule 42 (expr -> FLOAT ( expr ) .)
    THEN            reduce using rule 42 (expr -> FLOAT ( expr ) .)


state 121

    (43) expr -> INT ( expr ) .
    ]               reduce using rule 43 (expr -> INT ( expr ) .)
    /               reduce using rule 43 (expr -> INT ( expr ) .)
    *               reduce using rule 43 (expr -> INT ( expr ) .)
    -               reduce using rule 43 (expr -> INT ( expr ) .)
    +               reduce using rule 43 (expr -> INT ( expr ) .)
    )               reduce using rule 43 (expr -> INT ( expr ) .)
    ;               reduce using rule 43 (expr -> INT ( expr ) .)
    END             reduce using rule 43 (expr -> INT ( expr ) .)
    ELSE            reduce using rule 43 (expr -> INT ( expr ) .)
    DF              reduce using rule 43 (expr -> INT ( expr ) .)
    ET              reduce using rule 43 (expr -> INT ( expr ) .)
    GE              reduce using rule 43 (expr -> INT ( expr ) .)
    GT              reduce using rule 43 (expr -> INT ( expr ) .)
    LE              reduce using rule 43 (expr -> INT ( expr ) .)
    LT              reduce using rule 43 (expr -> INT ( expr ) .)
    ,               reduce using rule 43 (expr -> INT ( expr ) .)
    DO              reduce using rule 43 (expr -> INT ( expr ) .)
    OR              reduce using rule 43 (expr -> INT ( expr ) .)
    AND             reduce using rule 43 (expr -> INT ( expr ) .)
    THEN            reduce using rule 43 (expr -> INT ( expr ) .)


state 122

    (44) expr -> ID ( _4_exprlist_optional ) .
    ]               reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    /               reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    *               reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    -               reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    +               reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    )               reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    ;               reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    END             reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    ELSE            reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    DF              reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    ET              reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    GE              reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    GT              reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    LE              reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    LT              reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    ,               reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    DO              reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    OR              reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    AND             reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)
    THEN            reduce using rule 44 (expr -> ID ( _4_exprlist_optional ) .)


state 123

    (69) exprlist -> exprlist , . expr
    (42) expr -> . FLOAT ( expr )
    (43) expr -> . INT ( expr )
    (44) expr -> . ID ( _4_exprlist_optional )
    (47) expr -> . ID [ expr ]
    (48) expr -> . ID
    (49) expr -> . FCONST
    (50) expr -> . ICONST
    (51) expr -> . ( expr )
    (52) expr -> . + expr
    (53) expr -> . - expr
    (54) expr -> . expr / expr
    (55) expr -> . expr * expr
    (56) expr -> . expr - expr
    (57) expr -> . expr + expr
    FLOAT           shift and go to state 30
    INT             shift and go to state 33
    ID              shift and go to state 34
    FCONST          shift and go to state 35
    ICONST          shift and go to state 36
    (               shift and go to state 32
    +               shift and go to state 37
    -               shift and go to state 38

    expr                           shift and go to state 141

state 124

    (47) expr -> ID [ expr ] .
    ]               reduce using rule 47 (expr -> ID [ expr ] .)
    /               reduce using rule 47 (expr -> ID [ expr ] .)
    *               reduce using rule 47 (expr -> ID [ expr ] .)
    -               reduce using rule 47 (expr -> ID [ expr ] .)
    +               reduce using rule 47 (expr -> ID [ expr ] .)
    )               reduce using rule 47 (expr -> ID [ expr ] .)
    ;               reduce using rule 47 (expr -> ID [ expr ] .)
    END             reduce using rule 47 (expr -> ID [ expr ] .)
    ELSE            reduce using rule 47 (expr -> ID [ expr ] .)
    DF              reduce using rule 47 (expr -> ID [ expr ] .)
    ET              reduce using rule 47 (expr -> ID [ expr ] .)
    GE              reduce using rule 47 (expr -> ID [ expr ] .)
    GT              reduce using rule 47 (expr -> ID [ expr ] .)
    LE              reduce using rule 47 (expr -> ID [ expr ] .)
    LT              reduce using rule 47 (expr -> ID [ expr ] .)
    ,               reduce using rule 47 (expr -> ID [ expr ] .)
    DO              reduce using rule 47 (expr -> ID [ expr ] .)
    OR              reduce using rule 47 (expr -> ID [ expr ] .)
    AND             reduce using rule 47 (expr -> ID [ expr ] .)
    THEN            reduce using rule 47 (expr -> ID [ expr ] .)


state 125

    (23) stmt -> ID ( _3_exprlist_optional ) .
    ;               reduce using rule 23 (stmt -> ID ( _3_exprlist_optional ) .)
    END             reduce using rule 23 (stmt -> ID ( _3_exprlist_optional ) .)
    ELSE            reduce using rule 23 (stmt -> ID ( _3_exprlist_optional ) .)


state 126

    (40) location -> ID [ expr ] .
    ASSIGNOP        reduce using rule 40 (location -> ID [ expr ] .)
    )               reduce using rule 40 (location -> ID [ expr ] .)


state 127

    (33) stmt -> WHILE relation DO stmt .
    ;               reduce using rule 33 (stmt -> WHILE relation DO stmt .)
    END             reduce using rule 33 (stmt -> WHILE relation DO stmt .)
    ELSE            reduce using rule 33 (stmt -> WHILE relation DO stmt .)


state 128

    (60) relation -> relation OR relation .
    (60) relation -> relation . OR relation
    (61) relation -> relation . AND relation
    DO              reduce using rule 60 (relation -> relation OR relation .)
    OR              reduce using rule 60 (relation -> relation OR relation .)
    THEN            reduce using rule 60 (relation -> relation OR relation .)
    )               reduce using rule 60 (relation -> relation OR relation .)
    AND             shift and go to state 104


state 129

    (61) relation -> relation AND relation .
    (60) relation -> relation . OR relation
    (61) relation -> relation . AND relation
    DO              reduce using rule 61 (relation -> relation AND relation .)
    OR              reduce using rule 61 (relation -> relation AND relation .)
    AND             reduce using rule 61 (relation -> relation AND relation .)
    THEN            reduce using rule 61 (relation -> relation AND relation .)
    )               reduce using rule 61 (relation -> relation AND relation .)


state 130

    (58) relation -> ( relation ) .
    DO              reduce using rule 58 (relation -> ( relation ) .)
    OR              reduce using rule 58 (relation -> ( relation ) .)
    AND             reduce using rule 58 (relation -> ( relation ) .)
    THEN            reduce using rule 58 (relation -> ( relation ) .)
    )               reduce using rule 58 (relation -> ( relation ) .)


state 131

    (62) relation -> expr DF expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    DO              reduce using rule 62 (relation -> expr DF expr .)
    OR              reduce using rule 62 (relation -> expr DF expr .)
    AND             reduce using rule 62 (relation -> expr DF expr .)
    THEN            reduce using rule 62 (relation -> expr DF expr .)
    )               reduce using rule 62 (relation -> expr DF expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 132

    (63) relation -> expr ET expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    DO              reduce using rule 63 (relation -> expr ET expr .)
    OR              reduce using rule 63 (relation -> expr ET expr .)
    AND             reduce using rule 63 (relation -> expr ET expr .)
    THEN            reduce using rule 63 (relation -> expr ET expr .)
    )               reduce using rule 63 (relation -> expr ET expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 133

    (64) relation -> expr GE expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    DO              reduce using rule 64 (relation -> expr GE expr .)
    OR              reduce using rule 64 (relation -> expr GE expr .)
    AND             reduce using rule 64 (relation -> expr GE expr .)
    THEN            reduce using rule 64 (relation -> expr GE expr .)
    )               reduce using rule 64 (relation -> expr GE expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 134

    (65) relation -> expr GT expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    DO              reduce using rule 65 (relation -> expr GT expr .)
    OR              reduce using rule 65 (relation -> expr GT expr .)
    AND             reduce using rule 65 (relation -> expr GT expr .)
    THEN            reduce using rule 65 (relation -> expr GT expr .)
    )               reduce using rule 65 (relation -> expr GT expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 135

    (66) relation -> expr LE expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    DO              reduce using rule 66 (relation -> expr LE expr .)
    OR              reduce using rule 66 (relation -> expr LE expr .)
    AND             reduce using rule 66 (relation -> expr LE expr .)
    THEN            reduce using rule 66 (relation -> expr LE expr .)
    )               reduce using rule 66 (relation -> expr LE expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 136

    (67) relation -> expr LT expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    DO              reduce using rule 67 (relation -> expr LT expr .)
    OR              reduce using rule 67 (relation -> expr LT expr .)
    AND             reduce using rule 67 (relation -> expr LT expr .)
    THEN            reduce using rule 67 (relation -> expr LT expr .)
    )               reduce using rule 67 (relation -> expr LT expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 137

    (34) stmt -> READ ( location ) .
    ;               reduce using rule 34 (stmt -> READ ( location ) .)
    END             reduce using rule 34 (stmt -> READ ( location ) .)
    ELSE            reduce using rule 34 (stmt -> READ ( location ) .)


state 138

    (35) stmt -> WRITE ( expr ) .
    ;               reduce using rule 35 (stmt -> WRITE ( expr ) .)
    END             reduce using rule 35 (stmt -> WRITE ( expr ) .)
    ELSE            reduce using rule 35 (stmt -> WRITE ( expr ) .)


state 139

    (36) stmt -> PRINT ( literal ) .
    ;               reduce using rule 36 (stmt -> PRINT ( literal ) .)
    END             reduce using rule 36 (stmt -> PRINT ( literal ) .)
    ELSE            reduce using rule 36 (stmt -> PRINT ( literal ) .)


state 140

    (37) instr_open -> IF relation THEN stmt . ELSE stmt
    (38) instr_rel -> IF relation THEN stmt .
    ELSE            shift and go to state 142
    ;               reduce using rule 38 (instr_rel -> IF relation THEN stmt .)
    END             reduce using rule 38 (instr_rel -> IF relation THEN stmt .)


state 141

    (69) exprlist -> exprlist , expr .
    (54) expr -> expr . / expr
    (55) expr -> expr . * expr
    (56) expr -> expr . - expr
    (57) expr -> expr . + expr
    ,               reduce using rule 69 (exprlist -> exprlist , expr .)
    )               reduce using rule 69 (exprlist -> exprlist , expr .)
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 142

    (37) instr_open -> IF relation THEN stmt ELSE . stmt
    (23) stmt -> . ID ( _3_exprlist_optional )
    (26) stmt -> . location ASSIGNOP expr
    (27) stmt -> . RETURN expr
    (28) stmt -> . SKIP
    (29) stmt -> . BEGIN stmtlist END
    (30) stmt -> . instr_open
    (31) stmt -> . instr_rel
    (32) stmt -> . BREAK
    (33) stmt -> . WHILE relation DO stmt
    (34) stmt -> . READ ( location )
    (35) stmt -> . WRITE ( expr )
    (36) stmt -> . PRINT ( literal )
    (40) location -> . ID [ expr ]
    (41) location -> . ID
    (37) instr_open -> . IF relation THEN stmt ELSE stmt
    (38) instr_rel -> . IF relation THEN stmt
    ID              shift and go to state 41
    RETURN          shift and go to state 46
    SKIP            shift and go to state 47
    BEGIN           shift and go to state 42
    BREAK           shift and go to state 50
    WHILE           shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    PRINT           shift and go to state 54
    IF              shift and go to state 55

    stmt                           shift and go to state 143
    location                       shift and go to state 45
    instr_open                     shift and go to state 48
    instr_rel                      shift and go to state 49

state 143

    (37) instr_open -> IF relation THEN stmt ELSE stmt .
    ;               reduce using rule 37 (instr_open -> IF relation THEN stmt ELSE stmt .)
    END             reduce using rule 37 (instr_open -> IF relation THEN stmt ELSE stmt .)
    ELSE            reduce using rule 37 (instr_open -> IF relation THEN stmt ELSE stmt .)
